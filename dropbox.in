#!/usr/bin/python
#
# Copyright 2008 Evenflow, Inc.
#
# dropbox
# Dropbox frontend script
# This file is part of nautilus-dropbox @PACKAGE_VERSION@.
#
# nautilus-dropbox is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# nautilus-dropbox is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with nautilus-dropbox.  If not, see <http://www.gnu.org/licenses/>.
#

from __future__ import with_statement

import sys
import optparse
import socket
import os
import time
import platform
import tarfile
import threading
import urllib
import subprocess
import fcntl
import errno
import locale
from contextlib import closing

INFO = u"Dropbox is the easiest way to share and store your files online. Want to learn more? Head to"
LINK = u"http://www.getdropbox.com/"
WARNING = u"In order to use Dropbox, you must download the proprietary daemon."

DOWNLOADING = u"Downloading Dropbox... %d%%"
UNPACKING = u"Unpacking Dropbox... %d%%"

PARENT_DIR = os.path.expanduser("~")
DROPBOXD_PATH = "%s/.dropbox-dist/dropboxd" % PARENT_DIR

enc = locale.getpreferredencoding()
def console_flush(f=sys.stdout):
    f.flush()

def console_print(st, f=sys.stdout, linebreak=True):
    global enc
    assert type(st) is unicode
    f.write(st.encode(enc))
    if linebreak: f.write(os.linesep)
def console_flush(f=sys.stdout):
    f.flush()

def yes_no_question(question):
    while True:
        console_print(question, linebreak=False)
        console_print(u" [y/n] ", linebreak=False)
        console_flush()
        text = raw_input()
        if text.lower().startswith("y"):
            return True
        elif text.lower().startswith("n"):
            return False
        else:
            console_print(u"Sorry, I didn't understand that. Please type yes or no.")
    
def yes_no_question(question):
    while True:
        console_print(question, linebreak=False)
        console_print(u" [y/n] ", linebreak=False)
        console_flush()
        text = raw_input()
        if text.lower().startswith("y"):
            return True
        elif text.lower().startswith("n"):
            return False
        else:
            console_print(u"Sorry, I didn't understand that. Please type yes or no.")

def plat():
    if sys.platform.lower().startswith('linux'):
        arch = platform.machine()
        if (arch[0] == 'i' and
            arch[1].isdigit() and
            arch[2:4] == '86'):
            plat = "x86"
        elif arch == 'x86_64':
            plat = arch
        else:
            FatalVisibleError("Platform not supported")
        return "lnx.%s" % plat
    else:
        FatalVisibleError("Platform not supported")

# This sets a custom User-Agent
class DropboxURLopener(urllib.FancyURLopener):
    version = "DropboxLinuxDownloader/@PACKAGE_VERSION@"
urllib._urlopener = DropboxURLopener()

class DownloadState(object):
    def __init__(self):
        try:
            self.file = urllib.urlopen("http://www.getdropbox.com/download?plat=%s" % plat())
        except IOError:
            FatalVisibleError("Trouble connecting to Dropbox servers. Maybe your internet connection is down, or you need to set your http_proxy environment variable.")
            
        fcntl.fcntl(self.file, fcntl.F_SETFL, os.O_NONBLOCK)
        
        self.size = int(self.file.info()['content-length'])
        self.progress = 0

        self.local_path = "%s/dropbox.tar.gz" % PARENT_DIR
        self.local_file = open(self.local_path, 'wb')

    def copy_data(self):
        chunks = []
        def flush():
            while chunks:
                self.local_file.write(chunks.pop())
        while True:
            try:
                chunk = os.read(self.file.fileno(), 4096)
                self.progress += len(chunk)
                chunks.insert(0, chunk)
                yield True
                if self.progress == self.size:
                    break
            except OSError, e:
                if hasattr(e, 'errno') and e.errno == errno.EAGAIN:
                    # nothing left to read
                    flush()
                    yield False
                else:
                    raise
        flush()
        self.file.close()

    def unpack(self):
        self.local_file.close()
        archive = tarfile.open(self.local_path, 'r:gz')
        total_members = len(archive.getmembers())
        for i, member in enumerate(archive.getmembers()):
            archive.extract(member, PARENT_DIR)
            yield member.name, i, total_members
        archive.close()
        os.remove(self.local_path)

    def cancel(self):
        if not self.local_file.closed:
            self.local_file.close()
        if os.path.exists(self.local_path):
            os.remove(self.local_path)

def load_serialized_images():
    global box_logo_pixbuf, window_icon
    import gtk
    box_logo_pixbuf = @IMAGEDATA64@
    window_icon = @IMAGEDATA16@

if os.environ.get("DISPLAY", '') != '':
    def download():
        import pygtk
        pygtk.require("2.0")
        import gtk
        import gobject
        import pango
        import webbrowser

        load_serialized_images()

        global FatalVisibleError
        def FatalVisibleError(s):
            error = gtk.MessageDialog(parent = None,
                                      flags = gtk.DIALOG_MODAL,
                                      type = gtk.MESSAGE_ERROR,
                                      buttons = gtk.BUTTONS_OK,
                                      message_format = s)
            error.set_title("Error")
            error.run()
            gtk.main_quit()
            sys.exit(-1)

        def gtk_flush_events():
            while gtk.events_pending():
                gtk.main_iteration()

        class DownloadDialog(gtk.Dialog):
            def handle_cancel(self, button):
                if self.watch:
                    gobject.source_remove(self.watch)
                if self.download:
                    self.download.cancel()
                gtk.main_quit()
                self.user_cancelled = True

            def handle_ok(self, button):
                # begin download
                self.ok.hide()
                self.download = DownloadState()
                self.one_chunk = self.download.copy_data()
                self.watch = gobject.io_add_watch(self.download.file,
                                                  gobject.IO_IN | 
                                                  gobject.IO_PRI |
                                                  gobject.IO_ERR |
                                                  gobject.IO_HUP,
                                                  self.handle_data_waiting)
                self.label.hide()
                self.progress.show()

            def update_progress(self, text, fraction):
                self.progress.set_text(text % int(fraction*100))
                self.progress.set_fraction(fraction)
                gtk_flush_events()

            def handle_data_waiting(self, fd, condition):
                if condition == gobject.IO_HUP:
                    FatalVisibleError("Connection to server unexpectedly closed.")
                elif condition == gobject.IO_ERR:
                    FatalVisibleError("Unexpected error occurred with download.")
                try:
                    while self.one_chunk.next():
                        self.update_progress(DOWNLOADING, float(self.download.progress)/self.download.size)
                except StopIteration:
                    self.update_progress(DOWNLOADING, 1.0)
                    self.unpack_dropbox()
                    return False
                else:
                    self.update_progress(DOWNLOADING, float(self.download.progress)/self.download.size)
                    return True

            def unpack_dropbox(self):
                one_member = self.download.unpack()
                try:
                    while True:
                        name, i, total = one_member.next()
                        self.update_progress(UNPACKING, float(i)/total)
                except StopIteration:
                    self.update_progress(UNPACKING, 1.0)
                    gtk.main_quit()

            def mouse_down(self, widget, event):
                if self.hovering:
                    self.clicked_link = True

            def mouse_up(self, widget, event):
                if self.clicked_link:
                    webbrowser.open(LINK)
                    self.clicked_link = False

            def label_motion(self, widget, event):
                offx, offy = self.label.get_layout_offsets()
                layout = self.label.get_layout()
                index = layout.xy_to_index(int((offx+event.x)*pango.SCALE),
                                           int((offy+event.y)*pango.SCALE))[0]
                link_index = layout.get_text().find(LINK)
                if index >= link_index and index < link_index+len(LINK):
                    self.hovering = True
                    self.label_box.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.HAND2))
                else:
                    self.hovering = False
                    self.label_box.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.ARROW))


            def __init__(self):
                super(DownloadDialog, self).__init__(parent = None,
                                                     title = "Dropbox Installation")

                self.download = None
                self.watch = None
                self.hovering = False
                self.clicked_link = False
                self.user_cancelled = False

                self.ok = ok = gtk.Button(stock=gtk.STOCK_OK)
                ok.connect('clicked', self.handle_ok)
                self.action_area.add(ok)
                ok.show()

                cancel = gtk.Button(stock=gtk.STOCK_CANCEL)
                cancel.connect('clicked', self.handle_cancel)
                self.action_area.add(cancel)
                cancel.show()

                self.box_logo = gtk.image_new_from_pixbuf(box_logo_pixbuf)
                self.box_logo.show()

                self.set_icon(window_icon)

                self.progress = gtk.ProgressBar()
                self.progress.set_property('width-request', 300)

                self.label = gtk.Label()
                self.label.set_markup('%s <span foreground="#000099" underline="single" weight="bold">%s</span>\n\n%s' % (INFO, LINK, WARNING))
                self.label.set_line_wrap(True)
                self.label.set_property('width-request', 300)
                self.label.show()

                self.label_box = gtk.EventBox()
                self.label_box.add(self.label)
                self.label_box.connect("button-release-event", self.mouse_up)
                self.label_box.connect("button-press-event", self.mouse_down)
                self.label_box.connect("motion-notify-event", self.label_motion)
                self.label_box.show()
                def on_realize(widget):
                    self.label_box.add_events(gtk.gdk.POINTER_MOTION_MASK)
                self.label_box.connect("realize", on_realize)

                self.hbox = gtk.HBox(spacing=10)
                self.hbox.set_property('border-width',10)
                self.hbox.pack_start(self.box_logo, False, False)
                self.hbox.pack_start(self.label_box, False, False)
                self.hbox.pack_start(self.progress, False, False)
                self.hbox.show()

                self.vbox.add(self.hbox)
                self.set_resizable(False)

        dialog = DownloadDialog()
        dialog.show()
        gtk.main()
        if dialog.user_cancelled:
            raise Exception("user cancelled download!!!")
else:
    def download():
        global FatalVisibleError
        def FatalVisibleError(s):
            console_print(u"\nError: %s" % s, f=sys.stderr)
            sys.exit(-1)


        ESC = "\x1b"
        save = ESC+"7"
        unsave = ESC+"8"
        clear = ESC+"[2J"
        erase_to_start = ESC+"[1K"
        write = sys.stdout.write
        flush = sys.stdout.flush

        last_progress = [None, None]
        def setprogress(text, frac):
            if last_progress == [text, frac]:
                return
            if sys.stdout.isatty():
                write(erase_to_start)
                write(unsave)
            console_print(text % int(100*frac), linebreak=not sys.stdout.isatty())
            if sys.stdout.isatty():
                flush()
            last_progress[0], last_progress[1] = text, frac

        console_print(u"")
        if sys.stdout.isatty():
            write(save)
            flush()
        console_print(u"%s %s\n" % (INFO, LINK))

        if not yes_no_question(WARNING):
            return

        download = DownloadState()
        one_chunk = download.copy_data()

        try:    
            while True:
                one_chunk.next()
                setprogress(DOWNLOADING, float(download.progress)/download.size)
        except StopIteration:
            setprogress(DOWNLOADING, 1.0)
            console_print(u"")
            write(save)

        one_member = download.unpack()

        try:
            while True:
                name, i, total = one_member.next()
                setprogress(UNPACKING, float(i)/total)
        except StopIteration:
            setprogress(UNPACKING, 1.0)

        console_print(u"")

class DropboxCommand(object):
    class CouldntConnectError(Exception): pass
    class EOFError(Exception): pass
    class CommandError(Exception): pass

    def __init__(self):
        self.s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            self.s.connect(os.path.expanduser(u'~/.dropbox/command_socket'))
        except socket.error, e:
            raise DropboxCommand.CouldntConnectError()
        self.f = self.s.makefile("r+", 4096)

    def close(self):
        self.f.close()
        self.s.close()

    def __readline(self):
        toret = self.f.readline().decode('utf8').rstrip(u"\n")
        if toret == '':
            raise DropboxCommand.EOFError()
        else:
            return toret

    # atttribute doesn't exist, i know what you want
    def send_command(self, name, args):
        self.f.write(name.encode('utf8'))
        self.f.write(u"\n".encode('utf8'))
        self.f.writelines((u"\t".join([k] + (list(v)
                                             if hasattr(v, '__iter__') else
                                             [v])) + u"\n").encode('utf8')
                          for k,v in args.iteritems())
        self.f.write(u"done\n".encode('utf8'))
                
        self.f.flush()

        ok = self.__readline() == u"ok"
        if ok:
            toret = {}
            for i in range(21):
                if i == 20:
                    raise Exception(u"close this connection!")

                line = self.__readline()
                if line == u"done":
                    break
                        
                argval = line.split(u"\t")
                toret[argval[0]] = argval[1:]

            return toret
        else:
            problems = []
            for i in range(21):
                if i == 20:
                    raise Exception(u"close this connection!")

                line = self.__readline()
                if line == u"done":
                    break
                        
                problems.append(line)
                    
            raise DropboxCommand.CommandError(u"\n".join(problems))

    # this is the hotness, auto marshalling
    def __getattr__(self, name):
        try:
            return super(DropboxCommand, self).__getattr__(name)
        except:
            def __spec_command(**kw):
                return self.send_command(unicode(name), kw)
            self.__setattr__(name, __spec_command)
            return __spec_command

commands = {}

def command(meth):
    global commands
    assert meth.__doc__, "All commands need properly formatted docstrings (even %r!!)" % meth
    if hasattr(meth, 'im_func'): # bound method, if we ever have one
        meth = meth.im_func
    commands[meth.func_name] = meth
    return meth

def link_to_account(dc):
    fields = dc.get_link_args(new=yes_no_question(u"Do you already have a Dropbox account?"))
    print fields

def start_dropbox():
    db_path = os.path.expanduser(u"~/.dropbox-dist/dropboxd").encode(sys.getfilesystemencoding())
    if os.access(db_path, os.X_OK):
        f = open("/dev/null", "w")
        subprocess.Popen([db_path], preexec_fn=os.setsid, cwd=os.path.expanduser("~"),
                         stderr=f, stdout=f, close_fds=True)
        sys.stdout.flush()
        # in seconds
        interval = 0.5
        wait_for = 60
        for i in xrange(int(wait_for / interval)):
            try:
                with closing(DropboxCommand()) as dc:
                    if dc.needs_cli_link()["needs_link"]:
                        link_to_account(dc)
                    return True
            except:
                pass
                
            # back off from connect for a while
            time.sleep(interval)

        return False
    else:
        return False

@command
def filestatus(args):
    u"""get current sync status of one or more files
dropbox filestatus [-l] [-a] [FILE]...

Prints the current status of each FILE.

options:
  -l --list  prints out information in a format similar
             to ls. works best when your console supports
             color :)
  -a --all   do not ignore entries starting with .
"""
    oparser = optparse.OptionParser()
    oparser.add_option("-l", "--list", action="store_true", dest="list")
    oparser.add_option("-a", "--all", action="store_true", dest="all")
    (options, args) = oparser.parse_args(args)

    # first check if dropbox is already running
    try:
        with closing(DropboxCommand()) as dc:
            if options.list:
                # TODO: ls style columns

                if len(args) == 0:
                    dirs, nondirs = [u"."], []
                else:
                    dirs, nondirs = [], []

                    for a in args:
                        try:
                            (dirs if os.path.isdir(a) else
                             nondirs).append(a.decode(sys.getfilesystemencoding()))
                        except UnicodeDecodeError:
                            pass

                    if len(dirs) == 0 and len(nondirs) == 0:
                        exit(1)

                def lowerkey(st):
                    return st.lower()

                dirs.sort(key=lowerkey)
                nondirs.sort(key=lowerkey)

                def printstatus(fp):
                    status = dc.icon_overlay_file_status(path=fp).get(u'status',
                                                                      [None])[0]
                    if not sys.stdout.isatty():
                        console_print(os.path.basename(fp))
                        return

                    if status == u"up to date":
                        INIT, CLEANUP = "\x1b[32m", "\x1b[0m"
                    elif status == u"syncing":
                        INIT, CLEANUP = "\x1b[36m", "\x1b[0m"
                    elif status == u"unsyncable":
                        INIT, CLEANUP = "\x1b[41m", "\x1b[0m"
                    else:
                        INIT, CLEANUP = '', ''

                    console_print(u"%s%s%s" % (INIT, os.path.basename(fp), CLEANUP))

                def printdir(name):
                    for subname in sorted(os.listdir(name), key=lowerkey):
                        if type(subname) != unicode:
                            pass
                        
                        if not options.all and subname[0] == u'.':
                            continue

                        printstatus(os.path.abspath(os.path.join(name, subname)))

                if len(dirs) == 1 and len(nondirs) == 0:
                    printdir(dirs[0])
                else:
                    for name in nondirs:
                        printstatus(os.path.abspath(name))

                    if len(nondirs) == 0:
                        console_print(dirs[0] + u":")
                        printdir(dirs[0])
                        dirs = dirs[1:]

                    for name in dirs:
                        console_print(u"")
                        console_print(name + u":")
                        printdir(name)
            else:
                if len(args) == 0:
                    args = [name for name in os.listdir(u".") if type(name) == unicode]
                indent = max(len(st)+1 for st in args)
                for file in args:
                    fp = os.path.abspath(file)
                    if not os.path.exists(fp):
                        console_print(u"%-*s %s" % \
                                          (indent, file+':', "File doesn't exist"))
                        continue
                        
                    try:
                        status = dc.icon_overlay_file_status(path=fp).get(u'status', [u'unknown'])[0]
                        console_print(u"%-*s %s" % (indent, file+':', status))
                    except DropboxCommand.CommandError, e:
                        console_print(u"%-*s %s" % \
                                          (indent, file+':', e.message))
    except DropboxCommand.CouldntConnectError, e:
        console_print(u"Dropbox isn't running!")
    except DropboxCommand.EOFError:
        console_print(u"Dropbox daemon stopped.")

@command
def ls(args):
    u"""list directory contents with current sync status
dropbox ls [FILE]...

This is an alias for filestatus -l
"""
    return filestatus(["-l"] + args)

@command
def publicurl(args):
    u"""get public url of a file in your dropbox
dropbox publicurl [FILE]

Prints out a public url for FILE.
"""
    if len(args) != 1:
        console_print(publicurl.__doc__,linebreak=False)
        return

    try:
        with closing(DropboxCommand()) as dc:
            try:
                console_print(dc.get_public_link(path=os.path.abspath(args[0].decode(sys.getfilesystemencoding()))).get(u'link', [u'No Link'])[0])
            except DropboxCommand.CommandError, e:
                console_print(u"Couldn't get public url: " + e.message)
    except DropboxCommand.CouldntConnectError, e:
        console_print(u"Dropbox isn't running!")
    except DropboxCommand.EOFError:
        console_print(u"Dropbox daemon stopped.")

@command
def status(args):
    u"""get current status of the dropboxd
dropbox status

Prints out the current status of the
Dropbox daemon.
"""
    if len(args) != 0:
        console_print(publicurl.__doc__,linebreak=False)
        return

    try:
        with closing(DropboxCommand()) as dc:
            try:
                lines = dc.get_dropbox_status()[u'status']
                if len(lines) == 0:
                    console_print(u'Idle')                    
                else:
                    for line in lines:
                        console_print(line)
            except KeyError:
                console_print(u"Couldn't get status: daemon isn't responding")
            except DropboxCommand.CommandError, e:
                console_print(u"Couldn't get status: " + e.message)
    except DropboxCommand.CouldntConnectError, e:
        console_print(u"Dropbox isn't running!")
    except DropboxCommand.EOFError:
        console_print(u"Dropbox daemon stopped.")

@command
def stop(args):
    u"""stop dropboxd
dropbox stop

Stops the dropbox daemon.
"""
    # first check if dropbox is already running
    try:
        with closing(DropboxCommand()) as dc:
            dc.tray_action_hard_exit()
    except DropboxCommand.CouldntConnectError, e:
        console_print(u"Dropbox isn't running!")
    except DropboxCommand.EOFError:
        console_print(u"Dropbox daemon stopped.")

@command
def start(argv):
    u"""start dropboxd
dropbox start [-i]
    
Starts the dropbox daemon, dropboxd. If dropboxd is already running, this will
do nothing.

options:
  -i --install  auto install dropboxd if not available on the system
"""

    should_install = "-i" in argv or "--install" in argv
    
    # first check if dropbox is already running
    try:
        with closing(DropboxCommand()) as dc:
            console_print(u"Dropbox is already running!")
            return
    except:
        pass

    console_print(u"Starting Dropbox...", linebreak=False)
    if not start_dropbox():
        if not should_install:
            console_print(u"The Dropbox daemon is not installed!")
            console_print(u"Run with -i to install the daemon")
            return

        # install dropbox!!!
        try:
            download()
        except:
            pass
        else:
            start_dropbox()
    console_print(u"Done!")

@command
def help(argv):
    u"""provide help
dropbox help [COMMAND]

With no arguments, print a list of commands and a short description of each.

With a command, print descriptive help on how to use the command.
"""
    if not argv:
        return usage(argv)
    for command in commands:
        if command == argv[0]:
            console_print(commands[command].__doc__.split('\n', 1)[1].decode('ascii'))
            return
    console_print(u"unknown command '%s'" % argv[0], f=sys.stderr)

def usage(argv):
    console_print(u"Dropbox command-line interface\n")
    console_print(u"commands:\n")
    out = []
    for command in commands:
        out.append((command, commands[command].__doc__.splitlines()[0]))
    spacing = max(len(o[0])+3 for o in out)
    for o in out:
        console_print(" %-*s%s" % (spacing, o[0], o[1]))

def main(argv):
    global commands

    # now we need to find out if one of the commands are in the
    # argv list, and if so split the list at the point to
    # separate the argv list at that point
    cut = None
    for i in range(len(argv)):
        if argv[i] in commands:
            cut = i
            break
    
    if cut == None:
        usage(argv)
        return

    # lol no options for now
    globaloptionparser = optparse.OptionParser()
    globaloptionparser.parse_args(argv[0:i])

    # now dispatch and run
    return commands[argv[i]](argv[i+1:])

if __name__ == "__main__":
    main(sys.argv)
